function classify_image_simple(imagePath)
% Display input path for debugging
disp(['Processing image: ', imagePath]);

% Load classifier if not loaded
persistent classifier
if isempty(classifier)
try
load('faceClassifier.mat', 'classifier');
disp('Classifier loaded successfully');
catch ME
disp(['Error loading classifier: ', ME.message]);
classifier = [];
end
        end

% Read the image - using custom implementation
        try
img = custom_imread(imagePath);
disp('Image read successfully');
catch ME
disp(['Error reading image: ', ME.message]);
return;
end

% Resize image - using custom implementation
        img = custom_resize(img, [300 300]);

% Face detector - using custom implementation
        bboxes = custom_face_detector(img);

disp(['Number of faces detected: ', num2str(size(bboxes,1))]);

if ~isempty(bboxes)
% If classifier exists, use it to recognize faces
if ~isempty(classifier)
        imgSize = [100 100];
for i = 1:size(bboxes,1)
face = custom_imcrop(img, bboxes(i,:));
faceGray = custom_resize(custom_rgb2gray(face), imgSize);
hog = custom_extractHOGFeatures(faceGray);
try
        predictedLabel = classifier.predict(classifier, hog);
label = char(predictedLabel);
disp(['Face ', num2str(i), ' classified as: ', label]);
catch ME
disp(['Error classifying face: ', ME.message]);
label = 'Unknown';
end
        img = custom_insertObjectAnnotation(img, 'rectangle', bboxes(i,:), label);
end
else
disp('No classifier available, only marking face rectangles');
img = custom_insertShape(img, 'Rectangle', bboxes, 'LineWidth', 3, 'Color', 'green');
end
else
disp('No faces detected in the image');
end

% Save the output image
save_output_image(imagePath, img);
disp('Processing completed');
end

% Custom image reading function
function img = custom_imread(filepath)
fileID = fopen(filepath, 'rb');
if fileID == -1
error('Cannot open image file');
end

% For simplicity, we'll still use imread as creating a full image decoder is complex
% In a real implementation, this would be replaced with custom JPEG/PNG decoding
img = imread(filepath);
fclose(fileID);
end

% Custom RGB to grayscale conversion
        function gray = custom_rgb2gray(rgb)
if size(rgb, 3) == 3
% Standard RGB to grayscale formula: 0.2989 * R + 0.5870 * G + 0.1140 * B
        gray = 0.2989 * double(rgb(:,:,1)) + 0.5870 * double(rgb(:,:,2)) + 0.1140 * double(rgb(:,:,3));
gray = uint8(gray);
else
gray = rgb; % Already grayscale
end
        end

% Custom image resize function
function resized = custom_resize(img, new_size)
                   [orig_height, orig_width, channels] = size(img);

if length(new_size) ~= 2
error('New size must be a 2-element vector [height width]');
end

if numel(channels) == 0
channels = 1;
end

        resized = zeros(new_size(1), new_size(2), channels, 'uint8');

for c = 1:channels
for y = 1:new_size(1)
for x = 1:new_size(2)
% Map coordinates from target to source image
        src_x = ((x-1) * orig_width / new_size(2)) + 1;
src_y = ((y-1) * orig_height / new_size(1)) + 1;

% Simple nearest neighbor interpolation
x_idx = round(src_x);
y_idx = round(src_y);

% Boundary check
x_idx = max(1, min(orig_width, x_idx));
y_idx = max(1, min(orig_height, y_idx));

if channels == 1
resized(y, x) = img(y_idx, x_idx);
else
resized(y, x, c) = img(y_idx, x_idx, c);
end
        end
end
        end
end

% Custom HOG feature extraction
function hog_features = custom_extractHOGFeatures(img)
                        % Simple HOG implementation
% Parameters
        cell_size = 8;
block_size = 2;
num_bins = 9;

[height, width] = size(img);

% Calculate gradients
gradX = zeros(height, width);
gradY = zeros(height, width);

% Compute gradients (central difference)
for y = 2:height-1
for x = 2:width-1
gradX(y, x) = double(img(y, x+1)) - double(img(y, x-1));
gradY(y, x) = double(img(y+1, x)) - double(img(y-1, x));
end
        end

% Compute magnitude and orientation
magnitude = sqrt(gradX.^2 + gradY.^2);
orientation = atan2(gradY, gradX) * 180 / pi;
orientation(orientation < 0) = orientation(orientation < 0) + 180;

% Compute histograms in cells
cells_y = floor(height / cell_size);
cells_x = floor(width / cell_size);
histograms = zeros(cells_y, cells_x, num_bins);

for cell_y = 1:cells_y
for cell_x = 1:cells_x
for y = 1:cell_size
for x = 1:cell_size
        img_y = (cell_y-1)*cell_size + y;
img_x = (cell_x-1)*cell_size + x;

if img_y <= height && img_x <= width
        orient = orientation(img_y, img_x);
mag = magnitude(img_y, img_x);

% Determine histogram bin
        bin = min(floor(orient / (180/num_bins)) + 1, num_bins);
histograms(cell_y, cell_x, bin) = histograms(cell_y, cell_x, bin) + mag;
end
        end
end
        end
end

% Block normalization
blocks_y = cells_y - block_size + 1;
blocks_x = cells_x - block_size + 1;
features_per_block = block_size * block_size * num_bins;

hog_features = zeros(1, blocks_y * blocks_x * features_per_block);
feature_idx = 1;

for block_y = 1:blocks_y
for block_x = 1:blocks_x
        block_features = [];
for cell_y = block_y:block_y+block_size-1
for cell_x = block_x:block_x+block_size-1
block_features = [block_features, reshape(histograms(cell_y, cell_x, :), 1, [])];
end
        end

% Normalize block
block_norm = sqrt(sum(block_features.^2) + 1e-6);
block_features = block_features / block_norm;

% Add to feature vector
hog_features(feature_idx:feature_idx+features_per_block-1) = block_features;
feature_idx = feature_idx + features_per_block;
end
        end
end

% Custom image crop function
function cropped = custom_imcrop(img, bbox)
x = max(1, round(bbox(1)));
y = max(1, round(bbox(2)));
width = round(bbox(3));
height = round(bbox(4));

[img_height, img_width, channels] = size(img);

% Ensure dimensions are within image bounds
x_end = min(img_width, x + width - 1);
y_end = min(img_height, y + height - 1);

if channels == 1
cropped = img(y:y_end, x:x_end);
else
cropped = img(y:y_end, x:x_end, :);
end
        end

% Custom face detector implementation (Viola-Jones algorithm simplified)
function bboxes = custom_face_detector(img)
                  % For simplicity, we'll implement a very basic skin color-based face detector
% This is not as robust as Viola-Jones but gives us something to work with

% Convert to grayscale for edge detection
gray = custom_rgb2gray(img);

% Convert to YCbCr color space for skin detection (still using RGB)
[rows, cols, ~] = size(img);

% Initialize skin mask
        skin_mask = false(rows, cols);

% Simple skin color thresholding in RGB
% This is a very simplified approach
for i = 1:rows
for j = 1:cols
        r = double(img(i, j, 1));
g = double(img(i, j, 2));
b = double(img(i, j, 3));

% Basic skin color rule in RGB
if r > 95 && g > 40 && b > 20 && ...
r > g && r > b && ...
abs(r - g) > 15 && ...
r + g + b > 100
skin_mask(i, j) = true;
end
        end
end

% Find connected regions that could be faces
% Group connected pixels
        labeled = custom_bwlabel(skin_mask);

% Extract region properties (area, bounding box)
        regions = custom_regionprops(labeled);

% Filter regions based on size
        min_area = (rows * cols) * 0.005;  % At least 0.5% of image
max_area = (rows * cols) * 0.5;    % At most 50% of image

valid_regions = [];
for i = 1:length(regions)
if regions(i).Area > min_area && regions(i).Area < max_area
        valid_regions = [valid_regions; i];
end
        end

% Convert region data to bounding boxes
bboxes = zeros(length(valid_regions), 4);
for i = 1:length(valid_regions)
        region_idx = valid_regions(i);
                bboxes(i, :) = regions(region_idx).BoundingBox;
end
        end

% Custom connected components labeling algorithm
        function labeled = custom_bwlabel(bw)
                           [rows, cols] = size(bw);
labeled = zeros(rows, cols);

% Initialize label counter
        current_label = 0;

% First pass: assign preliminary labels
for i = 1:rows
for j = 1:cols
if bw(i, j)
% Check neighbors (4-connectivity)
neighbors = [];

% Top neighbor
if i > 1 && labeled(i-1, j) > 0
neighbors = [neighbors, labeled(i-1, j)];
end

% Left neighbor
if j > 1 && labeled(i, j-1) > 0
neighbors = [neighbors, labeled(i, j-1)];
end

if isempty(neighbors)
% No labeled neighbors, assign new label
        current_label = current_label + 1;
labeled(i, j) = current_label;
else
% Assign smallest label from neighbors
labeled(i, j) = min(neighbors);
end
        end
end
        end

% Second pass: merge equivalences (simplified)
% This is a very simplified version without proper equivalence tracking
for i = 1:rows
for j = 1:cols
if labeled(i, j) > 0
% Check neighbors again for lower labels
if i > 1 && labeled(i-1, j) > 0
labeled(i, j) = min(labeled(i, j), labeled(i-1, j));
end

if j > 1 && labeled(i, j-1) > 0
labeled(i, j) = min(labeled(i, j), labeled(i, j-1));
end

if i < rows && labeled(i+1, j) > 0
labeled(i, j) = min(labeled(i, j), labeled(i+1, j));
end

if j < cols && labeled(i, j+1) > 0
labeled(i, j) = min(labeled(i, j), labeled(i, j+1));
end
        end
end
        end

% Re-label components to ensure consecutive labels
unique_labels = unique(labeled);
unique_labels = unique_labels(unique_labels > 0);

for i = 1:length(unique_labels)
labeled(labeled == unique_labels(i)) = i;
end
        end

% Custom region properties extraction
function regions = custom_regionprops(labeled)
max_label = max(max(labeled));
regions = struct('Area', {}, 'BoundingBox', {});

for label = 1:max_label
% Find all pixels with current label
[y, x] = find(labeled == label);

if ~isempty(y)
% Calculate area
area = length(y);

% Calculate bounding box [x, y, width, height]
min_x = min(x);
min_y = min(y);
max_x = max(x);
max_y = max(y);
width = max_x - min_x + 1;
height = max_y - min_y + 1;

regions(label).Area = area;
regions(label).BoundingBox = [min_x, min_y, width, height];
end
        end
end

% Custom function to insert object annotations on image
function annotated = custom_insertObjectAnnotation(img, shape, bbox, label)
annotated = img;

% Draw rectangle
annotated = custom_insertShape(annotated, shape, bbox, 'LineWidth', 2, 'Color', 'red');

% Add text label
        x = bbox(1);
y = max(1, bbox(2) - 15); % Place text above box

% Simple text rendering (rectangle with text inside)
        text_height = 15;
        text_width = length(label) * 8; % Approximation

% Draw text background
for i = y:y+text_height
for j = x:x+text_width
if i > 0 && j > 0 && i <= size(annotated, 1) && j <= size(annotated, 2)
annotated(i, j, 1) = 255; % White background
annotated(i, j, 2) = 255;
annotated(i, j, 3) = 255;
end
        end
end

% We'll still need to use text insertion from MATLAB for proper text rendering
% In a real implementation, we would render text pixel by pixel
annotated = insertText(annotated, [x, y], label, 'BoxOpacity', 0, 'TextColor', 'black');
end

% Custom function to insert shapes on image
        function result = custom_insertShape(img, shape, boxes, varargin)
result = img;
[height, width, ~] = size(img);

% Parse optional arguments
        lineWidth = 1;
color = [255, 0, 0]; % Default to red

for i = 1:2:length(varargin)
if strcmpi(varargin{i}, 'LineWidth')
lineWidth = varargin{i+1};
elseif strcmpi(varargin{i}, 'Color')
if ischar(varargin{i+1})
switch lower(varargin{i+1})
case 'red'
color = [255, 0, 0];
case 'green'
color = [0, 255, 0];
case 'blue'
color = [0, 0, 255];
otherwise
        color = [255, 0, 0];
end
else
color = varargin{i+1};
end
        end
end

% Check if color is string and convert
if ischar(color)
switch lower(color)
case 'red'
color = [255, 0, 0];
case 'green'
color = [0, 255, 0];
case 'blue'
color = [0, 0, 255];
otherwise
        color = [255, 0, 0];
end
        end

% Convert to uint8 if necessary
if max(color) <= 1
color = uint8(color * 255);
else
color = uint8(color);
end

% Draw each box
if strcmpi(shape, 'Rectangle')
for i = 1:size(boxes, 1)
box = boxes(i, :);
x = max(1, round(box(1)));
y = max(1, round(box(2)));
w = round(box(3));
h = round(box(4));

% Draw horizontal lines
for j = max(1, x-lineWidth+1):min(width, x+w+lineWidth-1)
for l = 1:lineWidth
% Top line
if y+l-1 > 0 && y+l-1 <= height
result(y+l-1, j, 1) = color(1);
result(y+l-1, j, 2) = color(2);
result(y+l-1, j, 3) = color(3);
end

% Bottom line
if y+h-l > 0 && y+h-l <= height
result(y+h-l, j, 1) = color(1);
result(y+h-l, j, 2) = color(2);
result(y+h-l, j, 3) = color(3);
end
        end
end

% Draw vertical lines
for j = max(1, y-lineWidth+1):min(height, y+h+lineWidth-1)
for l = 1:lineWidth
% Left line
if x+l-1 > 0 && x+l-1 <= width
result(j, x+l-1, 1) = color(1);
result(j, x+l-1, 2) = color(2);
result(j, x+l-1, 3) = color(3);
end

% Right line